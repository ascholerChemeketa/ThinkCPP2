<section xml:id="variables-operators_other-types-errors"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Other Types of Errors</title>
  <p>
    <idx>
      <h>run-time error</h>
    </idx>
    <idx>
      <h>error</h>
      <h>run-time</h>
    </idx>
    <idx>
      <h>exception</h>
    </idx> The second type of error is a <term>run-time error</term>,
    so-called because it does not appear until after the program has started running. In C++, these
    errors generally occur because of an <term>exception</term> - an attempt to do an operation that is not allowed.</p>
    </p>

  <p>Run-time errors are rare in the simple programs you will see in the first few chapters, so it
    might be a while before you encounter one. When a run-time error occurs, the program <q>crashes</q>
    (terminates) and displays an error message that explains what happened. For example,
    this program attempts to divide by the integer 0, which is mathematically undefined:</p>

    
  <listing>
    <program xml:id="variables-operators_other-types-errors-1"
             interactive="activecode">
<xi:include href="../programs/variables-operators_other-types-errors-1.cpp" parse="text"/>
</program>
  </listing>

  <p>When you run it, you will see the output of line 6. You will not see any output from line 9 as the program never reached that spot! You also will see an error message indicating that there was a <q>Floating point exception</q>. Like the messages for compiler errors, the ones for logic errors sometimes take experience to understand.</p>

  <p>They also do not always give information about the location the error occurred. Here we know it was between line 6 (because we saw its output) and line 9 (because we did not see its output). To find out exactly where the issue is, we need to use a debugger (like the Codelens feature in the Activecode above) that lets us run the code line by line.</p>

  <insight><p>Sometimes while debugging it helps to add extra print statements to help diagnose exactly where an error occurs. Even something as simple as <q>Got to point A</q>, <q>Got to point B</q>, etc... can help you narrow down where a run-time error is occurring.</p></insight>

  <p><idx>
      <h>logic error</h>
    </idx>
    <idx>
      <h>error</h>
      <h>logic</h>
    </idx> The third type of error is a <term>logic error</term>. If your program
    has a logic error, it will compile and run without generating error messages, but it will not do
    the right thing. Instead, it will do exactly what you told it to do. For example, here is a
    program with a logic error: </p>

  <listing>
    <program xml:id="variables-operators_other-types-errors-1"
             interactive="activecode">
<xi:include href="../programs/variables-operators_other-types-errors-1.cpp" parse="text"/>
</program>
  </listing>

  <p>This program compiles and runs just fine. But the answer is not what we expect. <c>halfX</c> is set to 0, not 5.</p>

  <p>Identifying logic errors can be hard because you have to work backward, looking at the output
    of the program, trying to figure out why it is doing the wrong thing, and how to make it do the
    right thing. And often times, the issue is that the code does not <q>say</q> what you think it does. If you think <c>1 / 2</c> <q>says</q> <c>0.5</c>, it can be hard to find this error.</p>

  <p>Using a debugger to run this code line by line lets us see that <c>halfX</c> has the wrong value after line 7 executes. The problem is in the calculation there, and not the printing on line 8. Line 7 is doing multiple things. It first divides 1 by 2; it then multiplies that by x; it then stores the result into <c>halfX</c>. To find which part has the error, we might rewrite that line to be something like this:</p>

  <program>
    int half = 1 / 2;
    int halfX = half * x;
  </program>

  <p>Running that code in a debugger (or printing each variable after setting it) will reveal that there is something wrong with <c>1 / 2</c>. Hopefully at that point, we remember that integer division never produces a decimal answer and we switch to using doubles. If we don't remember that, at least we have a very simple question to ask someone else <q>Why does 1 / 2 give me 0?</q></p>

  <insight><p>Simple lines of code are easier to debug than complex ones. If you have a logic error, try to isolate it by breaking the code into smaller pieces and testing each one.</p>
  <p>It is also often easier for people to understand a larger number of simple lines of code than a few very complex ones. And the compiler will quite likely produce the same object code regardless of how you write it. So favor writing code that is easy to read and debug.</p>
  </insight>

</section>