<?xml version="1.0"?>
<section xml:id="variables-operators_multiple-assignment"
         xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Multiple assignment</title>
  <p>It is perfectly legal C++ to make more than one assignment to the same variable. The effect of
    the second assignment is to replace the old value of the variable with a new value. (This is why
    they are called <q>variables</q><mdash/>they can vary!)</p>

  <listing>
    <caption> This active code reassigns <pf>fred</pf> from 5 to 7 and prints both values out. </caption>
    <program label="variables-operators_multiple-assignment-program-1"
             interactive="activecode"
             line-numbers="yes">
      <code><![CDATA[
#include <iostream>
using namespace std;

int main() {
    int fred = 5;
    cout << fred;
    fred = 7;
    cout << fred;
}
        ]]></code>
    </program>
  </listing>
  <p>The output of this program is <pf>57</pf>, because the first time we print <pf>fred</pf> his value is 5,
    and the second time his value is 7.</p>
  <listing>
    <caption> This active code reassigns <pf>fred</pf> from 5 to 7 without printing out the initial value. </caption>
    <program label="variables-operators_multiple-assignment-program-2"
             interactive="activecode"
             line-numbers="yes">
      <code><![CDATA[
#include <iostream>
using namespace std;

int main() {
    int fred = 5;
    fred = 7;
    cout << fred;
}
        ]]></code>
    </program>
  </listing>

  <p>However, if we do not print <pf>fred</pf> the first time, the output is only 7 because the value of <pf>fred</pf>
    is just 7 when it is printed.</p>

  <p>To picture this kind of <term>multiple assignment</term> you can think of a variable as the name of a <em>
    container</em> for values. When you assign a value to a variable, you change the contents of the
    container with that name, as shown in the figure:</p>
  <figure align="center">
    <image source="images/multiple-assign.png"
           width="50%"
           >
      <shortdescription>An assignment of 'fred = 7' changing the existing value of 'fred'.</shortdescription>
    </image>
  </figure>

  <p>Using one variable to assign the value of another copies the value of the first variable into the second variable. This means that after the assignment, there are two copies of the same value. But the variables that hold those values are independent. Changing one will not change the other:</p>

  <listing>
  <program label="variables-operators_multiple-assignment-program-3"
           interactive="codelens">
<xi:include href="../../programs/variables-operators/multiple-assignment-1.cpp" parse="text"/>
</program>
  </listing>

  <insight>
  <p>In mathematics, a statement of equality is true for all time. If <m>a = b</m> now,
    then <m>a</m> will always equal <m>b</m>. In C++, an assignment statement can't permanently make two variables equal. All it can do it copy the current value from one variable to another.</p>
  </insight>

  <p>Although multiple assignment is frequently useful, you should use it with caution. If the
    values of variables are changing constantly in different parts of the program, it can make the
    code difficult to read and debug. You generally should only use it when the same conceptual value changes. If you are programming a game, using multiple assignment to change the <pf>score</pf> variable every time the player scores points would make sense. But using multiple assignment to reuse variables for different purposes is generally a bad idea. Having a variable <pf>length</pf> that initially stores a value in inches and later is changed to store a value in centimeters would cause confusion for anyone trying to read the code.</p>

  <exercise label="variables-operators_multiple-assignment-ex-1">
    <statement>
      <p>What will print?</p>
      <program line-numbers="yes">
        <code><![CDATA[
#include <iostream>
using namespace std;

int main() {
  int x = 10;
  cout << x << "!";
  x = 1;
  cout << x << "!";
}
]]></code>
      </program>
    </statement>
    <choices randomize="yes">
      <choice correct="yes">
        <statement>
          <p>10!1!</p>
        </statement>
        <feedback> There are no spaces between the numbers. </feedback>
      </choice>
      <choice>
        <statement>
          <p>10 ! 1 !</p>
        </statement>
        <feedback> Remember, in C++ spaces must be printed. </feedback>
      </choice>
      <choice>
        <statement>
          <p>10 ! 10 !</p>
        </statement>
        <feedback> Carefully look at the values being assigned. </feedback>
      </choice>
      <choice>
        <statement>
          <p>1!1!</p>
        </statement>
        <feedback> Carefully look at the values being assigned. </feedback>
      </choice>
    </choices>
  </exercise>
  <exercise label="variables-operators_multiple-assignment-ex-2">
    <statement>
      <p>What is the correct output? Draw a memory diagram and keep track of the current value of each variable while you mentally <q>run</q> the code.</p>
      <program line-numbers="yes">
        <code><![CDATA[
int x = 0;
x = 5;
int y = x;
y = 3;
bool z = x;
x = 10;
cout << z;
]]></code>
      </program>
    </statement>
    <choices randomize="yes">
      <choice correct="yes">
        <statement>
          <p>5</p>
        </statement>
        <feedback>That is the value that x has when z was assigned</feedback>
      </choice>
      <choice>
        <statement>
          <p>3</p>
        </statement>
        <feedback>That is the value y has when z is assigned. It no longer has the same value as x.</feedback>
      </choice>
      <choice>
        <statement>
          <p>0</p>
        </statement>
        <feedback>That was the original value of x.</feedback>
      </choice>
      <choice>
        <statement>
          <p>10</p>
        </statement>
        <feedback>That is the value x gets after z has been assigned.</feedback>
      </choice>
    </choices>
  </exercise>
</section>