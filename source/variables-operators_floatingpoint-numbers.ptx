<section xml:id="variables-operators_floatingpoint-numbers"
         xmlns:xi="http://www.w3.org/2001/XInclude">

  <title>Floating-Point Numbers</title>
  <p>
    <idx>
      <h>floating-point</h>
    </idx>
    <idx>
      <h>double</h>
    </idx>
    <idx>
      <h>type</h>
      <h>double</h>
    </idx>So what do you do if you want to divide 45 by 60 and get 0.75? In C++, the answer is to use <term>floating-point</term> numbers,
    which represent values with decimal places. In C++, the default floating-point type is called <c>double</c>,
    which is short for <q>double-precision</q>. You can create <c>double</c> variables and assign values
    to them the same way we did for the other types: </p>

  <program xml:id="variables-operators_floatingpoint-numbers-1"
           interactive="activecode">
<xi:include href="../programs/variables-operators_floatingpoint-numbers-1.cpp" parse="text"/>
</program>

  <p>
    <idx>
      <h>division</h>
      <h>floating-point</h>
    </idx> C++ performs <term>floating-point division</term> when one or
    more operands are <c>double</c> values. So we can solve the problem from the previous section: </p>

  <program xml:id="variables-operators_floatingpoint-numbers-2"
           interactive="activecode">
<xi:include href="../programs/variables-operators_floatingpoint-numbers-2.cpp" parse="text"/>
</program>

  <p>Although floating-point numbers are useful, they can be a source of confusion. For example,
    C++ distinguishes the integer value <c>60</c> from the floating-point value <c>60.0</c>, even though
    they seem to be the same number. They belong to different data types, and thus doing math with them can produce different results.</p>

  <p>Adding to the confusion is the fact that C++ will automatically <q>upgrade</q> an <c>int</c> to a <c>double</c> if you try to store a whole number value into a double variable. This is called <term>implicit conversion</term>. Even worse, if you print a value like 4.0, the unnecessary decimal portion is left off:
  <idx>
    <h>implicit conversion</h>
  </idx></p>

  <program xml:id="variables-operators_floatingpoint-numbers-3"
           interactive="activecode">
<xi:include href="../programs/variables-operators_floatingpoint-numbers-3.cpp" parse="text"/>
  </program>

  <p>C++ can do the implicit conversions because any integer can be safely represent as a decimal value. The opposite is not true. There is no way to represent <c>3.14159</c> as a whole number without losing information. This code sample demonstrates what happens:</p>

  <program xml:id="variables-operators_floatingpoint-numbers-4"
           interactive="activecode">
<xi:include href="../programs/variables-operators_floatingpoint-numbers-4.cpp" parse="text"/>
  </program>

  <p>Turning a decimal number into an integer can be done by dropping the decimal part. But doing so does change the value you are representing. So the compiler warns that there may be an issue but then goes ahead and does the conversion.</p>

  <p>If you do an operation with an <c>int</c> and a <c>double</c>, the <c>int</c> is automatically converted to a <c>double</c> before the operation is performed. But, this does not happen until there is a calculation that needs to be performed involving the double. So the order of operations can matter. For example, consider the following code:
  </p>

  <program xml:id="variables-operators_floatingpoint-numbers-5"
           interactive="activecode">
<xi:include href="../programs/variables-operators_floatingpoint-numbers-5.cpp" parse="text"/>
</program>

  <p>You might expect value to be 0.33333 times 3.14159. But the first step in evaluating the expression
  <c>1 / 3 * 3.14159</c> is dividing 1 by 3. Those are both integers, so C++ does whole number division and
  gets the result <c>0</c>. It does not matter that later the math involves a double, or that the result is
  stored into a double. At the point of the division, the math involves two integers, so the result is an integer.
  Then the 0 is multiplied by 3.14159. At this point the 0 is promoted to a double - 0.0 - but that is too
  late to help produce the result we would expect.</p>

  <p>One way to solve this problem (once you figure out the logic error) is to make sure that if you want a decimal
  answer, that you do math with decimal values. This code works as expected: </p>

  <program xml:id="variables-operators_floatingpoint-numbers-6"
           interactive="activecode">
<xi:include href="../programs/variables-operators_floatingpoint-numbers-6.cpp" parse="text"/>
  </program>

  
  <p>Identifying whether an operation carries out integer division or floating point division
    can get tricky when we have a mix of integers and doubles in our expression.
    The thing to remeber is if either the divisor or the dividend is a double
    then the program will carry out floating point division.</p>
  <listing label="floating_point_a1">
    <caption>
      Run the code to see what type of division occurs each time.
    </caption>
    <program label="floating_point_a1_editor"
             interactive="activecode"
             line-numbers="yes">
      <code><![CDATA[
#include <iostream>
using namespace std;

int main() {
    double value = 5.0/2; //(a)
    cout << "current value (a) is " << value << endl;

    value = 5/2.0; //(b)
    cout << "current value (b) is " << value << endl;

    value = 5/2; //(c)
    cout << "current value (c) is " << value << endl;

    value = 5.0/2.0; //(d)
    cout << "current value (d) is " << value << endl;
}
        ]]></code>
    </program>
  </listing>

  <insight>
  <p>As long as either operand is a floating-point value, the operator will use floating-point math. If both operands are integers, the operator will use integer math.
  </p>
  <p>Doing integer math when you want to do floating-point math (with something like <c>1 / 3</c>) is a common logic error that can be hard to catch, since your program will compile without warnings.</p>
  </insight>

  <note>
  <p>All the operations we have seen&#x2014;addition, subtraction, multiplication,
    and division&#x2014;work on floating-point values, although you might be
    interested to know that the underlying mechanism is completely
    different. In fact, most processors have special hardware just for
    performing floating-point operations. It generally takes longer to perform a given calculation
    using floating point hardware. That is one of the reasons why we have two different basic numeric types.</p>
  </note>

  
  <exercise label="floating_point_2">
    <statement>
      <p>It's your birthday and your cake can serve 12. You want to slice it evenly so that you and
        each of your 4 friends receive an equal amount. One of your friends wants to know the serving size of his slice. You write the following code in C++ to answer
        her question:</p>
        
        <program>
          int servings = 12;
          int people = 5;
          
          double servingSize = servings / people;</program>

        <p>The program claims <c>servingSize</c> is <fillin mode="string" case="insensitive" answer="2"/> servings.
          This is <fillin mode="string" case="insensitive" answer="less"/> (more, less, the same) than/as the correct answer.</p>
    </statement>
    <evaluation>
      <evaluate>
          <test>
            <strcmp use-answer="yes"/>
            <feedback>
              Correct! C++ performs integer division.
            </feedback>
          </test>
          <test>
            <strcmp>.*</strcmp>
            <feedback>
              Hint: servingSize and people are integer variables!
            </feedback>
          </test>
      </evaluate>
      <evaluate>
          <test>
            <strcmp use-answer="yes"/>
          </test>
          <test>
            <strcmp>.*</strcmp>
            <feedback>
              Is the answer the program computes more or less than you would get if you did decimal division?
            </feedback>
          </test>
      </evaluate>
    </evaluation>
  </exercise>
  <exercise label="floating_point_3">
    <statement>
      <p>In the lab, we measured a temperature of 7.99999999 degrees C, using
        an extremely precise measuring device. Now we are writing a program
        to perform some calculations with our data. Consider the following C++
        code.</p>
      <program>double temp = 7.99999999;
int temp_int = temp;
double temp_double = temp_int;
cout &lt;&lt; temp_double;</program>
      <p>What is the value of <c>temp_double</c> that is printed to the terminal?</p>
    </statement>
    <choices>
      <choice>
        <statement>
          <p>temp_double</p>
        </statement>
        <feedback>
          This is the name of a variable. Only the value of a variable will print with cout.
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>8</p>
        </statement>
        <feedback>
          Converting to an int always rounds down.
        </feedback>
      </choice>
      <choice correct="yes">
        <statement>
          <p>7</p>
        </statement>
        <feedback>
          When we converted temp to an int, it was rounded down to 7. When we converted temp_int to
            temp_double, the decimal places from temp were lost, and the value of temp_double is 7.
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>8.0</p>
        </statement>
        <feedback>
          Converting to an int always rounds down.
        </feedback>
      </choice>
      <choice>
        <statement>
          <p>7.99999999</p>
        </statement>
        <feedback>
          When we converted temp to an int, all the decimal places were lost. Turning temp_int into a double
            does not bring them back.
        </feedback>
      </choice>
    </choices>
  </exercise>
</section>